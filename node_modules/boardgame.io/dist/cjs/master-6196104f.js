'use strict';

var _rollupPluginBabelHelpers = require('./_rollupPluginBabelHelpers-af0a4e52.js');
var redux = require('redux');
var reducer = require('./reducer-c8fe777c.js');
var initialize = require('./initialize-4fe5e709.js');

var GameMetadataKey = function GameMetadataKey(gameID) {
  return "".concat(gameID, ":metadata");
};

var getPlayerMetadata = function getPlayerMetadata(gameMetadata, playerID) {
  if (gameMetadata && gameMetadata.players) {
    return gameMetadata.players[playerID];
  }
};
/**
 * Redact the log.
 *
 * @param {Array} log - The game log (or deltalog).
 * @param {String} playerID - The playerID that this log is
 *                            to be sent to.
 */

function redactLog(log, playerID) {
  if (log === undefined) {
    return log;
  }

  return log.map(function (logEvent) {
    // filter for all other players and spectators.
    if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {
      return logEvent;
    }

    if (logEvent.redact !== true) {
      return logEvent;
    }

    var payload = _rollupPluginBabelHelpers._objectSpread2({}, logEvent.action.payload, {
      args: null
    });

    var filteredEvent = _rollupPluginBabelHelpers._objectSpread2({}, logEvent, {
      action: _rollupPluginBabelHelpers._objectSpread2({}, logEvent.action, {
        payload: payload
      })
    });
    /* eslint-disable-next-line no-unused-vars */


    var redact = filteredEvent.redact,
        remaining = _rollupPluginBabelHelpers._objectWithoutProperties(filteredEvent, ["redact"]);

    return remaining;
  });
}
/**
 * Verifies that the game has metadata and is using credentials.
 */

var doesGameRequireAuthentication = function doesGameRequireAuthentication(gameMetadata) {
  if (!gameMetadata) return false;
  var players = gameMetadata.players;
  var hasCredentials = Object.keys(players).some(function (key) {
    return !!(players[key] && players[key].credentials);
  });
  return hasCredentials;
};
/**
 * Verifies that the move came from a player with the correct credentials.
 */

var isActionFromAuthenticPlayer = function isActionFromAuthenticPlayer(actionCredentials, playerMetadata) {
  if (!actionCredentials) return false;
  if (!playerMetadata) return false;
  return actionCredentials === playerMetadata.credentials;
};
/**
 * Master
 *
 * Class that runs the game and maintains the authoritative state.
 * It uses the transportAPI to communicate with clients and the
 * storageAPI to communicate with the database.
 */

var Master =
/*#__PURE__*/
function () {
  function Master(game, storageAPI, transportAPI, auth) {
    _rollupPluginBabelHelpers._classCallCheck(this, Master);

    this.game = reducer.Game(game);
    this.storageAPI = storageAPI;
    this.transportAPI = transportAPI;
    this.auth = null;

    this.subscribeCallback = function () {};

    this.shouldAuth = function () {
      return false;
    };

    if (auth === true) {
      this.auth = isActionFromAuthenticPlayer;
      this.shouldAuth = doesGameRequireAuthentication;
    } else if (typeof auth === 'function') {
      this.auth = auth;

      this.shouldAuth = function () {
        return true;
      };
    }
  }

  _rollupPluginBabelHelpers._createClass(Master, [{
    key: "subscribe",
    value: function subscribe(fn) {
      this.subscribeCallback = fn;
    }
    /**
     * Called on each move / event made by the client.
     * Computes the new value of the game state and returns it
     * along with a deltalog.
     */

  }, {
    key: "onUpdate",
    value: async function onUpdate(action, stateID, gameID, playerID) {
      var _this = this;

      var isActionAuthentic;

      var _ref = action.payload || {},
          credentials = _ref.credentials;

      if (this.executeSynchronously) {
        var gameMetadata = this.storageAPI.get(GameMetadataKey(gameID));
        var playerMetadata = getPlayerMetadata(gameMetadata, playerID);
        isActionAuthentic = this.shouldAuth(gameMetadata) ? this.auth(credentials, playerMetadata) : true;
      } else {
        var _gameMetadata = await this.storageAPI.get(GameMetadataKey(gameID));

        var _playerMetadata = getPlayerMetadata(_gameMetadata, playerID);

        isActionAuthentic = this.shouldAuth(_gameMetadata) ? await this.auth(credentials, _playerMetadata) : true;
      }

      if (!isActionAuthentic) {
        return {
          error: 'unauthorized action'
        };
      }

      var key = gameID;
      var state;

      if (this.executeSynchronously) {
        state = this.storageAPI.get(key);
      } else {
        state = await this.storageAPI.get(key);
      }

      if (state === undefined) {
        reducer.error("game not found, gameID=[".concat(key, "]"));
        return {
          error: 'game not found'
        };
      }

      if (state.ctx.gameover !== undefined) {
        reducer.error("game over - gameID=[".concat(key, "]"));
        return;
      }

      var reducer$1 = reducer.CreateGameReducer({
        game: this.game,
        numPlayers: state.ctx.numPlayers
      });
      var store = redux.createStore(reducer$1, state); // Only allow UNDO / REDO if there is exactly one player
      // that can make moves right now and the person doing the
      // action is that player.

      if (action.type == reducer.UNDO || action.type == reducer.REDO) {
        if (state.ctx.currentPlayer !== playerID || state.ctx.activePlayers !== null) {
          reducer.error("playerID=[".concat(playerID, "] cannot undo / redo right now"));
          return;
        }
      } // Check whether the player is active.


      if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {
        reducer.error("player not active - playerID=[".concat(playerID, "]"));
        return;
      } // Check whether the player is allowed to make the move.


      if (action.type == reducer.MAKE_MOVE && !this.game.flow.getMove(state.ctx, action.payload.type, playerID)) {
        reducer.error("move not processed - canPlayerMakeMove=false, playerID=[".concat(playerID, "]"));
        return;
      }

      if (state._stateID !== stateID) {
        reducer.error("invalid stateID, was=[".concat(stateID, "], expected=[").concat(state._stateID, "]"));
        return;
      }

      var log = store.getState().log || []; // Update server's version of the store.

      store.dispatch(action);
      state = store.getState();
      this.subscribeCallback({
        state: state,
        action: action,
        gameID: gameID
      });
      this.transportAPI.sendAll(function (playerID) {
        var filteredState = _rollupPluginBabelHelpers._objectSpread2({}, state, {
          G: _this.game.playerView(state.G, state.ctx, playerID),
          ctx: _rollupPluginBabelHelpers._objectSpread2({}, state.ctx, {
            _random: undefined
          }),
          log: undefined,
          deltalog: undefined,
          _undo: [],
          _redo: [],
          _initial: _rollupPluginBabelHelpers._objectSpread2({}, state._initial, {
            _undo: [],
            _redo: []
          })
        });

        var log = redactLog(state.deltalog, playerID);
        return {
          type: 'update',
          args: [gameID, filteredState, log]
        };
      }); // TODO: We currently attach the log back into the state
      // object before storing it, but this should probably
      // sit in a different part of the database eventually.

      log = [].concat(_rollupPluginBabelHelpers._toConsumableArray(log), _rollupPluginBabelHelpers._toConsumableArray(state.deltalog));

      var stateWithLog = _rollupPluginBabelHelpers._objectSpread2({}, state, {
        log: log
      });

      if (this.executeSynchronously) {
        this.storageAPI.set(key, stateWithLog);
      } else {
        await this.storageAPI.set(key, stateWithLog);
      }
    }
    /**
     * Called when the client connects / reconnects.
     * Returns the latest game state and the entire log.
     */

  }, {
    key: "onSync",
    value: async function onSync(gameID, playerID, numPlayers) {
      var key = gameID;
      var state, gameMetadata, filteredGameMetadata;

      if (this.executeSynchronously) {
        state = this.storageAPI.get(key);
        gameMetadata = this.storageAPI.get(GameMetadataKey(gameID));
      } else {
        state = await this.storageAPI.get(key);
        gameMetadata = await this.storageAPI.get(GameMetadataKey(gameID));
      }

      if (gameMetadata) {
        filteredGameMetadata = Object.values(gameMetadata.players).map(function (player) {
          return {
            id: player.id,
            name: player.name
          };
        });
      } // If the game doesn't exist, then create one on demand.
      // TODO: Move this out of the sync call.


      if (state === undefined) {
        state = initialize.InitializeGame({
          game: this.game,
          numPlayers: numPlayers
        });
        this.subscribeCallback({
          state: state,
          gameID: gameID
        });

        if (this.executeSynchronously) {
          this.storageAPI.set(key, state);
          state = this.storageAPI.get(key);
        } else {
          await this.storageAPI.set(key, state);
          state = await this.storageAPI.get(key);
        }
      }

      var filteredState = _rollupPluginBabelHelpers._objectSpread2({}, state, {
        G: this.game.playerView(state.G, state.ctx, playerID),
        ctx: _rollupPluginBabelHelpers._objectSpread2({}, state.ctx, {
          _random: undefined
        }),
        log: undefined,
        deltalog: undefined,
        _undo: [],
        _redo: [],
        _initial: _rollupPluginBabelHelpers._objectSpread2({}, state._initial, {
          _undo: [],
          _redo: []
        })
      });

      var log = redactLog(state.log, playerID);
      this.transportAPI.send({
        playerID: playerID,
        type: 'sync',
        args: [gameID, filteredState, log, filteredGameMetadata]
      });
      return;
    }
  }]);

  return Master;
}();

exports.Master = Master;
