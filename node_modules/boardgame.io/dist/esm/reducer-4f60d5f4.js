import { _ as _toConsumableArray, a as _objectSpread2, b as _typeof, c as _createClass, d as _objectWithoutProperties, e as _classCallCheck } from './_rollupPluginBabelHelpers-b44b7feb.js';
import produce from 'immer';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
var MAKE_MOVE = 'MAKE_MOVE';
var GAME_EVENT = 'GAME_EVENT';
var REDO = 'REDO';
var RESET = 'RESET';
var SYNC = 'SYNC';
var UNDO = 'UNDO';
var UPDATE = 'UPDATE';

/*
 * Copyright 2017 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Generate a move to be dispatched to the game move reducer.
 *
 * @param {string} type - The move type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */

var makeMove = function makeMove(type, args, playerID, credentials) {
  return {
    type: MAKE_MOVE,
    payload: {
      type: type,
      args: args,
      playerID: playerID,
      credentials: credentials
    }
  };
};
/**
 * Generate a game event to be dispatched to the flow reducer.
 *
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */

var gameEvent = function gameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: {
      type: type,
      args: args,
      playerID: playerID,
      credentials: credentials
    }
  };
};
/**
 * Generate an automatic game event that is a side-effect of a move.
 * @param {string} type - The event type.
 * @param {Array}  args - Additional arguments.
 * @param {string}  playerID - The ID of the player making this action.
 * @param {string}  credentials - (optional) The credentials for the player making this action.
 */

var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {
  return {
    type: GAME_EVENT,
    payload: {
      type: type,
      args: args,
      playerID: playerID,
      credentials: credentials
    },
    automatic: true
  };
};
/**
 * Used to reset the Redux store's state on a sync.
 * @param {object} state - The state to restore.
 * @param {Array} log - The log to restore.
 */

var sync = function sync(state, log) {
  return {
    type: SYNC,
    state: state,
    log: log,
    clientOnly: true
  };
};
/**
 * Used to update the Redux store's state in response to
 * an action coming from another player.
 * @param {object} state - The state to restore.
 * @param {Array} deltalog - A log delta.
 */

var update = function update(state, deltalog) {
  return {
    type: UPDATE,
    state: state,
    deltalog: deltalog,
    clientOnly: true
  };
};
/**
 * Used to reset the game state.
 * @param {object} state - The initial state.
 */

var reset = function reset(state) {
  return {
    type: RESET,
    state: state,
    clientOnly: true
  };
};
/**
 * Used to undo the last move.
 */

var undo = function undo() {
  return {
    type: UNDO
  };
};
/**
 * Used to redo the last undone move.
 */

var redo = function redo() {
  return {
    type: REDO
  };
};

var ActionCreators = /*#__PURE__*/Object.freeze({
  makeMove: makeMove,
  gameEvent: gameEvent,
  automaticGameEvent: automaticGameEvent,
  sync: sync,
  update: update,
  reset: reset,
  undo: undo,
  redo: redo
});

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
/**
 * Plugin that allows using Immer to make immutable changes
 * to G by just mutating it.
 */

var PluginImmer = {
  fnWrap: function fnWrap(move) {
    return produce(move);
  }
};

/**
 * List of plugins that are always added.
 */

var DEFAULT_PLUGINS = [PluginImmer];
var Setup = {
  /**
   * Applies the provided plugins to G during game setup.
   *
   * @param {object} G - The G object.
   * @param {object} ctx - The ctx object.
   * @param {object} game - The game object.
   */
  G: function G(_G, ctx, game) {
    [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {
      return plugin.setup !== undefined;
    }).filter(function (plugin) {
      return plugin.setup.G !== undefined;
    }).forEach(function (plugin) {
      _G = plugin.setup.G(_G, ctx, game);
    });
    return _G;
  },

  /**
   * Applies the provided plugins to ctx during game setup.
   *
   * @param {object} ctx - The ctx object.
   * @param {object} game - The game object.
   */
  ctx: function ctx(_ctx, game) {
    [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {
      return plugin.setup !== undefined;
    }).filter(function (plugin) {
      return plugin.setup.ctx !== undefined;
    }).forEach(function (plugin) {
      _ctx = plugin.setup.ctx(_ctx, game);
    });
    return _ctx;
  }
};
/**
 * Applies the provided plugins to the given move / flow function.
 *
 * @param {function} fn - The move function or trigger to apply the plugins to.
 * @param {object} plugins - The list of plugins.
 */

var FnWrap = function FnWrap(fn, plugins) {
  var reducer = function reducer(acc, _ref) {
    var fnWrap = _ref.fnWrap;
    return fnWrap(acc, plugins);
  };

  return [].concat(DEFAULT_PLUGINS, _toConsumableArray(plugins)).filter(function (plugin) {
    return plugin.fnWrap !== undefined;
  }).reduce(reducer, fn);
};
/**
 * Applies the provided plugins before a move.
 *
 * @param {object} state - The game state.
 * @param {object} plugins - The list of plugins.
 */

var BeforeMove = function BeforeMove(state, plugins) {
  [].concat(DEFAULT_PLUGINS, _toConsumableArray(plugins)).filter(function (plugin) {
    return plugin.beforeMove !== undefined;
  }).forEach(function (plugin) {
    state = plugin.beforeMove(state);
  });
  return state;
};
/**
 * Applies the provided plugins before an event.
 *
 * @param {object} state - The game state.
 * @param {object} plugins - The list of plugins.
 */

var BeforeEvent = function BeforeEvent(state, plugins) {
  [].concat(DEFAULT_PLUGINS, _toConsumableArray(plugins)).filter(function (plugin) {
    return plugin.beforeEvent !== undefined;
  }).forEach(function (plugin) {
    state = plugin.beforeEvent(state);
  });
  return state;
};
/**
 * Applies the provided plugins after a move (and it's triggers).
 *
 * @param {object} state - The game state.
 * @param {object} plugins - The list of plugins.
 */

var AfterMove = function AfterMove(state, plugins) {
  [].concat(DEFAULT_PLUGINS, _toConsumableArray(plugins)).filter(function (plugin) {
    return plugin.afterMove !== undefined;
  }).forEach(function (plugin) {
    state = plugin.afterMove(state);
  });
  return state;
};
/**
 * Applies the provided plugins after an event (and it's triggers).
 *
 * @param {object} state - The game state.
 * @param {object} plugins - The list of plugins.
 */

var AfterEvent = function AfterEvent(state, plugins) {
  [].concat(DEFAULT_PLUGINS, _toConsumableArray(plugins)).filter(function (plugin) {
    return plugin.afterEvent !== undefined;
  }).forEach(function (plugin) {
    state = plugin.afterEvent(state);
  });
  return state;
};

/*
 * Copyright 2018 The boardgame.io Authors
 *
 * Use of this source code is governed by a MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */
var production = process.env.NODE_ENV === 'production';
var logfn = production ? function () {} : console.log;
var errorfn = console.error;
function info(msg) {
  logfn("INFO: ".concat(msg));
}
function error(error) {
  errorfn('ERROR:', error);
}

/**
 * Event to change the active players (and their stages) in the current turn.
 */

function SetActivePlayersEvent(state, _playerID, arg) {
  return _objectSpread2({}, state, {
    ctx: SetActivePlayers(state.ctx, arg)
  });
}
function SetActivePlayers(ctx, arg) {
  var _prevActivePlayers = ctx._prevActivePlayers;

  var _nextActivePlayers = arg.next || null;

  if (arg.revert) {
    _prevActivePlayers = _prevActivePlayers.concat({
      activePlayers: ctx.activePlayers,
      _activePlayersMoveLimit: ctx._activePlayersMoveLimit,
      _activePlayersNumMoves: ctx._activePlayersNumMoves
    });
  } else {
    _prevActivePlayers = [];
  }

  var activePlayers = {};
  var _activePlayersMoveLimit = {};

  if (Array.isArray(arg)) {
    var value = {};
    arg.forEach(function (v) {
      return value[v] = Stage.NULL;
    });
    activePlayers = value;
  }

  if (arg.currentPlayer !== undefined) {
    ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, ctx.currentPlayer, arg.currentPlayer);
  }

  if (arg.others !== undefined) {
    for (var i = 0; i < ctx.playOrder.length; i++) {
      var id = ctx.playOrder[i];

      if (id !== ctx.currentPlayer) {
        ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, id, arg.others);
      }
    }
  }

  if (arg.all !== undefined) {
    for (var _i = 0; _i < ctx.playOrder.length; _i++) {
      var _id = ctx.playOrder[_i];
      ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, _id, arg.all);
    }
  }

  if (arg.value) {
    for (var _id2 in arg.value) {
      ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, _id2, arg.value[_id2]);
    }
  }

  if (arg.moveLimit) {
    for (var _id3 in activePlayers) {
      if (_activePlayersMoveLimit[_id3] === undefined) {
        _activePlayersMoveLimit[_id3] = arg.moveLimit;
      }
    }
  }

  if (Object.keys(activePlayers).length == 0) {
    activePlayers = null;
  }

  if (Object.keys(_activePlayersMoveLimit).length == 0) {
    _activePlayersMoveLimit = null;
  }

  var _activePlayersNumMoves = {};

  for (var _id4 in activePlayers) {
    _activePlayersNumMoves[_id4] = 0;
  }

  return _objectSpread2({}, ctx, {
    activePlayers: activePlayers,
    _activePlayersMoveLimit: _activePlayersMoveLimit,
    _activePlayersNumMoves: _activePlayersNumMoves,
    _prevActivePlayers: _prevActivePlayers,
    _nextActivePlayers: _nextActivePlayers
  });
}
/**
 * Update activePlayers, setting it to previous, next or null values
 * when it becomes empty.
 * @param {Object} ctx
 */

function UpdateActivePlayersOnceEmpty(ctx) {
  var _ctx = ctx,
      activePlayers = _ctx.activePlayers,
      _activePlayersMoveLimit = _ctx._activePlayersMoveLimit,
      _activePlayersNumMoves = _ctx._activePlayersNumMoves,
      _prevActivePlayers = _ctx._prevActivePlayers;

  if (activePlayers && Object.keys(activePlayers).length == 0) {
    if (ctx._nextActivePlayers) {
      ctx = SetActivePlayers(ctx, ctx._nextActivePlayers);
      var _ctx2 = ctx;
      activePlayers = _ctx2.activePlayers;
      _activePlayersMoveLimit = _ctx2._activePlayersMoveLimit;
      _activePlayersNumMoves = _ctx2._activePlayersNumMoves;
      _prevActivePlayers = _ctx2._prevActivePlayers;
    } else if (_prevActivePlayers.length > 0) {
      var lastIndex = _prevActivePlayers.length - 1;
      var _prevActivePlayers$la = _prevActivePlayers[lastIndex];
      activePlayers = _prevActivePlayers$la.activePlayers;
      _activePlayersMoveLimit = _prevActivePlayers$la._activePlayersMoveLimit;
      _activePlayersNumMoves = _prevActivePlayers$la._activePlayersNumMoves;
      _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);
    } else {
      activePlayers = null;
      _activePlayersMoveLimit = null;
    }
  }

  return _objectSpread2({}, ctx, {
    activePlayers: activePlayers,
    _activePlayersMoveLimit: _activePlayersMoveLimit,
    _activePlayersNumMoves: _activePlayersNumMoves,
    _prevActivePlayers: _prevActivePlayers
  });
}
/**
 * Apply an active player argument to the given player ID
 * @param {Object} activePlayers
 * @param {Object} _activePlayersMoveLimit
 * @param {String} playerID The player to apply the parameter to
 * @param {(String|Object)} arg An active player argument
 */

function ApplyActivePlayerArgument(activePlayers, _activePlayersMoveLimit, playerID, arg) {
  if (_typeof(arg) !== 'object' || arg === Stage.NULL) {
    arg = {
      stage: arg
    };
  }

  if (arg.stage !== undefined) {
    activePlayers[playerID] = arg.stage;
    if (arg.moveLimit) _activePlayersMoveLimit[playerID] = arg.moveLimit;
  }
}
/**
 * Converts a playOrderPos index into its value in playOrder.
 * @param {Array} playOrder - An array of player ID's.
 * @param {number} playOrderPos - An index into the above.
 */


function getCurrentPlayer(playOrder, playOrderPos) {
  return playOrder[playOrderPos] + '';
}
/**
 * Called at the start of a turn to initialize turn order state.
 *
 * TODO: This is called inside StartTurn, which is called from
 * both UpdateTurn and StartPhase (so it's called at the beginning
 * of a new phase as well as between turns). We should probably
 * split it into two.
 *
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turn - A turn object for this phase.
 */


function InitTurnOrderState(G, ctx, turn) {
  var order = turn.order;

  var playOrder = _toConsumableArray(new Array(ctx.numPlayers)).map(function (d, i) {
    return i + '';
  });

  if (order.playOrder !== undefined) {
    playOrder = order.playOrder(G, ctx);
  }

  var playOrderPos = order.first(G, ctx);
  var currentPlayer = getCurrentPlayer(playOrder, playOrderPos);
  ctx = _objectSpread2({}, ctx, {
    currentPlayer: currentPlayer,
    playOrderPos: playOrderPos,
    playOrder: playOrder
  });
  ctx = SetActivePlayers(ctx, turn.activePlayers || {});
  return ctx;
}
/**
 * Called at the end of each turn to update the turn order state.
 * @param {object} G - The game object G.
 * @param {object} ctx - The game object ctx.
 * @param {object} turn - A turn object for this phase.
 * @param {string} endTurnArg - An optional argument to endTurn that
                                may specify the next player.
 */

function UpdateTurnOrderState(G, ctx, turn, endTurnArg) {
  var order = turn.order;
  var playOrderPos = ctx.playOrderPos;
  var currentPlayer = ctx.currentPlayer;
  var endPhase = false;

  if (endTurnArg && endTurnArg !== true) {
    if (_typeof(endTurnArg) !== 'object') {
      error("invalid argument to endTurn: ".concat(endTurnArg));
    }

    Object.keys(endTurnArg).forEach(function (arg) {
      switch (arg) {
        case 'remove':
          currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
          break;

        case 'next':
          playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);
          currentPlayer = endTurnArg.next;
          break;

        default:
          error("invalid argument to endTurn: ".concat(arg));
      }
    });
  } else {
    var t = order.next(G, ctx);

    if (t === undefined) {
      endPhase = true;
    } else {
      playOrderPos = t;
      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
    }
  }

  ctx = _objectSpread2({}, ctx, {
    playOrderPos: playOrderPos,
    currentPlayer: currentPlayer
  });
  return {
    endPhase: endPhase,
    ctx: ctx
  };
}
/**
 * Set of different turn orders possible in a phase.
 * These are meant to be passed to the `turn` setting
 * in the flow objects.
 *
 * Each object defines the first player when the phase / game
 * begins, and also a function `next` to determine who the
 * next player is when the turn ends.
 *
 * The phase ends if next() returns undefined.
 */

var TurnOrder = {
  /**
   * DEFAULT
   *
   * The default round-robin turn order.
   */
  DEFAULT: {
    first: function first(G, ctx) {
      return ctx.turn === 0 ? ctx.playOrderPos : (ctx.playOrderPos + 1) % ctx.playOrder.length;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * RESET
   *
   * Similar to DEFAULT, but starts from 0 each time.
   */
  RESET: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * CONTINUE
   *
   * Similar to DEFAULT, but starts with the player who ended the last phase.
   */
  CONTINUE: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      return (ctx.playOrderPos + 1) % ctx.playOrder.length;
    }
  },

  /**
   * ONCE
   *
   * Another round-robin turn order, but goes around just once.
   * The phase ends after all players have played.
   */
  ONCE: {
    first: function first() {
      return 0;
    },
    next: function next(G, ctx) {
      if (ctx.playOrderPos < ctx.playOrder.length - 1) {
        return ctx.playOrderPos + 1;
      }
    }
  },

  /**
   * CUSTOM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase.
   *
   * @param {Array} playOrder - The play order.
   */
  CUSTOM: function CUSTOM(_playOrder) {
    return {
      playOrder: function playOrder() {
        return _playOrder;
      },
      first: function first() {
        return 0;
      },
      next: function next(G, ctx) {
        return (ctx.playOrderPos + 1) % ctx.playOrder.length;
      }
    };
  },

  /**
   * CUSTOM_FROM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase to a value specified by a field
   * in G.
   *
   * @param {string} playOrderField - Field in G.
   */
  CUSTOM_FROM: function CUSTOM_FROM(playOrderField) {
    return {
      playOrder: function playOrder(G) {
        return G[playOrderField];
      },
      first: function first() {
        return 0;
      },
      next: function next(G, ctx) {
        return (ctx.playOrderPos + 1) % ctx.playOrder.length;
      }
    };
  },

  /**
   * SKIP
   *
   * Round-robin, but skips over any players that have passed.
   * Meant to be used with Pass above.
   */
  SKIP: {
    first: function first(G, ctx) {
      return ctx.playOrderPos;
    },
    next: function next(G, ctx) {
      if (G.allPassed) return;
      var playOrderPos = ctx.playOrderPos;

      for (var i = 0; i < ctx.playOrder.length; i++) {
        playOrderPos = (playOrderPos + 1) % ctx.playOrder.length;

        if (!G.passOrder.includes(ctx.playOrder[playOrderPos] + '')) {
          return playOrderPos;
        }
      }
    }
  }
};
var Stage = {
  NULL: null
};
var ActivePlayers = {
  /**
   * ALL
   *
   * The turn stays with one player, but any player can play (in any order)
   * until the phase ends.
   */
  ALL: {
    all: Stage.NULL
  },

  /**
   * ALL_ONCE
   *
   * The turn stays with one player, but any player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every player in the game.
   */
  ALL_ONCE: {
    all: Stage.NULL,
    moveLimit: 1
  },

  /**
   * OTHERS
   *
   * The turn stays with one player, and every *other* player can play (in any order)
   * until the phase ends.
   */
  OTHERS: {
    others: Stage.NULL
  },

  /**
   * OTHERS_ONCE
   *
   * The turn stays with one player, and every *other* player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every *other* player in the game.
   */
  OTHERS_ONCE: {
    others: Stage.NULL,
    moveLimit: 1
  }
};

// Inlined version of Alea from https://github.com/davidbau/seedrandom.

/*
 * Copyright 2015 David Bau.
 *
 * Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software
 * and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
function Alea(seed) {
  var me = this,
      mash = Mash();

  me.next = function () {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32

    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  }; // Apply the seeding algorithm from Baagoe.


  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);

  if (me.s0 < 0) {
    me.s0 += 1;
  }

  me.s1 -= mash(seed);

  if (me.s1 < 0) {
    me.s1 += 1;
  }

  me.s2 -= mash(seed);

  if (me.s2 < 0) {
    me.s2 += 1;
  }

  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function mash(data) {
    data = data.toString();

    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }

    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}

function alea(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.quick = prng;

  if (state) {
    if (_typeof(state) == 'object') copy(state, xg);

    prng.state = function () {
      return copy(xg, {});
    };
  }

  return prng;
}

/**
 * Random
 *
 * Calls that require a pseudorandom number generator.
 * Uses a seed from ctx, and also persists the PRNG
 * state in ctx so that moves can stay pure.
 */

var Random =
/*#__PURE__*/
function () {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  function Random(ctx) {
    _classCallCheck(this, Random);

    // If we are on the client, the seed is not present.
    // Just use a temporary seed to execute the move without
    // crashing it. The move state itself is discarded,
    // so the actual value doesn't matter.
    this.state = ctx._random || {
      seed: '0'
    };
  }
  /**
   * Updates ctx with the PRNG state.
   * @param {object} ctx - The ctx object to update.
   */


  _createClass(Random, [{
    key: "update",
    value: function update(state) {
      var ctx = _objectSpread2({}, state.ctx, {
        _random: this.state
      });

      return _objectSpread2({}, state, {
        ctx: ctx
      });
    }
    /**
     * Attaches the Random API to ctx.
     * @param {object} ctx - The ctx object to attach to.
     */

  }, {
    key: "attach",
    value: function attach(ctx) {
      return _objectSpread2({}, ctx, {
        random: this._api()
      });
    }
    /**
     * Generate a random number.
     */

  }, {
    key: "_random",
    value: function _random() {
      var R = this.state;
      var fn;

      if (R.prngstate === undefined) {
        // No call to a random function has been made.
        fn = new alea(R.seed, {
          state: true
        });
      } else {
        fn = new alea('', {
          state: R.prngstate
        });
      }

      var number = fn();
      this.state = _objectSpread2({}, R, {
        prngstate: fn.state()
      });
      return number;
    }
  }, {
    key: "_api",
    value: function _api() {
      var random = this._random.bind(this);

      var SpotValue = {
        D4: 4,
        D6: 6,
        D8: 8,
        D10: 10,
        D12: 12,
        D20: 20
      }; // Generate functions for predefined dice values D4 - D20.

      var predefined = {};

      var _loop = function _loop(key) {
        var spotvalue = SpotValue[key];

        predefined[key] = function (diceCount) {
          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return _toConsumableArray(new Array(diceCount).keys()).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        };
      };

      for (var key in SpotValue) {
        _loop(key);
      }

      return _objectSpread2({}, predefined, {
        /**
         * Roll a die of specified spot value.
         *
         * @param {number} spotvalue - The die dimension (default: 6).
         * @param {number} diceCount - number of dice to throw.
         *                             if not defined, defaults to 1 and returns the value directly.
         *                             if defined, returns an array containing the random dice values.
         */
        Die: function Die(spotvalue, diceCount) {
          if (spotvalue === undefined) {
            spotvalue = 6;
          }

          if (diceCount === undefined) {
            return Math.floor(random() * spotvalue) + 1;
          } else {
            return _toConsumableArray(new Array(diceCount).keys()).map(function () {
              return Math.floor(random() * spotvalue) + 1;
            });
          }
        },

        /**
         * Generate a random number between 0 and 1.
         */
        Number: function Number() {
          return random();
        },

        /**
         * Shuffle an array.
         *
         * @param {Array} deck - The array to shuffle. Does not mutate
         *                       the input, but returns the shuffled array.
         */
        Shuffle: function Shuffle(deck) {
          var clone = deck.slice(0);
          var srcIndex = deck.length;
          var dstIndex = 0;
          var shuffled = new Array(srcIndex);

          while (srcIndex) {
            var randIndex = srcIndex * random() | 0;
            shuffled[dstIndex++] = clone[randIndex];
            clone[randIndex] = clone[--srcIndex];
          }

          return shuffled;
        }
      });
    }
  }]);

  return Random;
}();
/**
 * Removes the attached Random api from ctx.
 *
 * @param {object} ctx - The ctx object with the Random API attached.
 * @returns {object} A plain ctx object without the Random API.
 */

Random.detach = function (ctx) {
  var random = ctx.random,
      rest = _objectWithoutProperties(ctx, ["random"]); // eslint-disable-line no-unused-vars


  return rest;
};
/**
 * Generates a new seed from the current date / time.
 */


Random.seed = function () {
  return (+new Date()).toString(36).slice(-10);
};

/**
 * Events
 */

var Events =
/*#__PURE__*/
function () {
  function Events(flow, playerID) {
    _classCallCheck(this, Events);

    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
  }
  /**
   * Attaches the Events API to ctx.
   * @param {object} ctx - The ctx object to attach to.
   */


  _createClass(Events, [{
    key: "attach",
    value: function attach(ctx) {
      var _this = this;

      var events = {};
      var phase = ctx.phase,
          turn = ctx.turn;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var key = _step.value;

          events[key] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this.dispatch.push({
              key: key,
              args: args,
              phase: phase,
              turn: turn
            });
          };
        };

        for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return _objectSpread2({}, ctx, {
        events: events
      });
    }
    /**
     * Updates ctx with the triggered events.
     * @param {object} state - The state object { G, ctx }.
     */

  }, {
    key: "update",
    value: function update(state) {
      for (var i = 0; i < this.dispatch.length; i++) {
        var item = this.dispatch[i]; // If the turn already ended some other way,
        // don't try to end the turn again.

        if (item.key === 'endTurn' && item.turn !== state.ctx.turn) {
          continue;
        } // If the phase already ended some other way,
        // don't try to end the phase again.


        if ((item.key === 'endPhase' || item.key === 'setPhase') && item.phase !== state.ctx.phase) {
          continue;
        }

        var action = automaticGameEvent(item.key, item.args, this.playerID);
        state = _objectSpread2({}, state, {}, this.flow.processEvent(state, action));
      }

      return state;
    }
  }]);

  return Events;
}();
/**
 * Detaches the Events API from ctx.
 * @param {object} ctx - The ctx object to strip.
 */

Events.detach = function (ctx) {
  var events = ctx.events,
      rest = _objectWithoutProperties(ctx, ["events"]); // eslint-disable-line no-unused-vars


  return rest;
};

/**
 * Context API to allow writing custom logs in games.
 */

var GameLoggerCtxAPI =
/*#__PURE__*/
function () {
  function GameLoggerCtxAPI() {
    _classCallCheck(this, GameLoggerCtxAPI);

    this._payload = undefined;
  }

  _createClass(GameLoggerCtxAPI, [{
    key: "_api",
    value: function _api() {
      var _this = this;

      return {
        setPayload: function setPayload(payload) {
          _this._payload = payload;
        }
      };
    }
  }, {
    key: "attach",
    value: function attach(ctx) {
      return _objectSpread2({}, ctx, {
        log: this._api()
      });
    }
  }, {
    key: "update",
    value: function update(state) {
      if (this._payload === undefined) {
        return state;
      } // attach the payload to the last log event


      var deltalog = state.deltalog;
      deltalog[deltalog.length - 1] = _objectSpread2({}, deltalog[deltalog.length - 1], {
        payload: this._payload
      });
      this._payload = undefined;
      return _objectSpread2({}, state, {
        deltalog: deltalog
      });
    }
  }], [{
    key: "detach",
    value: function detach(ctx) {
      var log = ctx.log,
          ctxWithoutLog = _objectWithoutProperties(ctx, ["log"]); // eslint-disable-line no-unused-vars


      return ctxWithoutLog;
    }
  }]);

  return GameLoggerCtxAPI;
}();
/**
 * This class is used to attach/detach various utility objects
 * onto a ctx, without having to manually attach/detach them
 * all separately.
 */

var ContextEnhancer =
/*#__PURE__*/
function () {
  function ContextEnhancer(ctx, game, player) {
    _classCallCheck(this, ContextEnhancer);

    this.random = new Random(ctx);
    this.events = new Events(game.flow, player);
    this.log = new GameLoggerCtxAPI();
  }

  _createClass(ContextEnhancer, [{
    key: "attachToContext",
    value: function attachToContext(ctx) {
      var ctxWithAPI = this.random.attach(ctx);
      ctxWithAPI = this.events.attach(ctxWithAPI);
      ctxWithAPI = this.log.attach(ctxWithAPI);
      return ctxWithAPI;
    }
  }, {
    key: "_update",
    value: function _update(state, updateEvents) {
      var newState = updateEvents ? this.events.update(state) : state;
      newState = this.random.update(newState);
      newState = this.log.update(newState);
      return newState;
    }
  }, {
    key: "updateAndDetach",
    value: function updateAndDetach(state, updateEvents) {
      var newState = this._update(state, updateEvents);

      newState.ctx = ContextEnhancer.detachAllFromContext(newState.ctx);
      return newState;
    }
  }], [{
    key: "detachAllFromContext",
    value: function detachAllFromContext(ctx) {
      var ctxWithoutAPI = Random.detach(ctx);
      ctxWithoutAPI = Events.detach(ctxWithoutAPI);
      ctxWithoutAPI = GameLoggerCtxAPI.detach(ctxWithoutAPI);
      return ctxWithoutAPI;
    }
  }]);

  return ContextEnhancer;
}();

/**
 * Flow
 *
 * Creates a reducer that updates ctx (analogous to how moves update G).
 *
 * @param {...object} endIf - The game automatically ends if this function
 *                            returns anything (checked after each move).
 *                            The return value is available at ctx.gameover.
 *                            (G, ctx) => {}
 *
 * @param {...object} turn - Customize the turn structure (see turn-order.js).
 *
 * {
 *   // The turn order.
 *   order: TurnOrder.DEFAULT,
 *
 *   // Code to run at the beginning of the turn.
 *   onBegin: (G, ctx) => G,
 *
 *   // Code to run at the end of the turn.
 *   onEnd: (G, ctx) => G,
 *
 *   // The turn automatically ends if this returns a truthy
 *   // value (checked after each move).
 *   // If the return value is { next: playerID },
 *   // then that player is the next player
 *   // instead of following the turn order.
 *   endIf: (G, ctx) => boolean|object,
 *
 *   // End the turn automatically after a certain number
 *   // of moves.
 *   moveLimit: 1,
 *
 *   // Code to run at the end of a move.
 *   onMove: (G, ctx, { type: 'moveName', args: [] }) => G
 * }
 *
 * @param {...object} events - Section that allows enabling / disabling events.
 *
 * {
 *   endTurn - Set to false to disable the `endTurn` event.
 *
 *   endPhase - Set to false to disable the `endPhase` event.
 *
 *   endGame - Set to true to enable the `endGame` event.
 * }
 *
 *
 * @param {...object} phases - A map of phases in the game.
 *
 * {
 *   // Any setup code to run before the phase begins.
 *   onBegin: (G, ctx) => G,
 *
 *   // Any cleanup code to run after the phase ends.
 *   onEnd: (G, ctx) => G,
 *
 *   // The phase ends if this function returns a truthy value.
 *   // If the return value is of the form { next: 'phase name' }
 *   // then that will be chosen as the next phase.
 *   endIf: (G, ctx) => boolean|object,
 *
 *   // A phase-specific set of moves that overrides the global.
 *   moves: { ... },
 *
 *   // A phase-specific turn structure that overrides the global.
 *   turn: { ... },
 *
 *   // Set to true to begin the game in this phase. Only one phase
 *   // can have this set to true.
 *   start: false,
 * }
 */

function Flow(_ref) {
  var moves = _ref.moves,
      phases = _ref.phases,
      endIf = _ref.endIf,
      turn = _ref.turn,
      events = _ref.events,
      plugins = _ref.plugins;

  // Attach defaults.
  if (moves === undefined) {
    moves = {};
  }

  if (events === undefined) {
    events = {};
  }

  if (plugins === undefined) {
    plugins = [];
  }

  if (phases === undefined) {
    phases = {};
  }

  if (!endIf) endIf = function endIf() {
    return undefined;
  };
  if (!turn) turn = {};

  var phaseMap = _objectSpread2({}, phases);

  if ('' in phaseMap) {
    error('cannot specify phase with empty name');
  }

  phaseMap[''] = {};
  var moveMap = {};
  var moveNames = new Set();
  var startingPhase = null;
  Object.keys(moves).forEach(function (name) {
    return moveNames.add(name);
  });

  for (var phase in phaseMap) {
    var conf = phaseMap[phase];

    if (conf.start === true) {
      startingPhase = phase;
    }

    if (conf.moves !== undefined) {
      for (var _i = 0, _Object$keys = Object.keys(conf.moves); _i < _Object$keys.length; _i++) {
        var move = _Object$keys[_i];
        moveMap[phase + '.' + move] = conf.moves[move];
        moveNames.add(move);
      }
    }

    if (conf.endIf === undefined) {
      conf.endIf = function () {
        return undefined;
      };
    }

    if (conf.onBegin === undefined) {
      conf.onBegin = function (G) {
        return G;
      };
    }

    if (conf.onEnd === undefined) {
      conf.onEnd = function (G) {
        return G;
      };
    }

    if (conf.turn === undefined) {
      conf.turn = turn;
    }

    if (conf.turn.order === undefined) {
      conf.turn.order = TurnOrder.DEFAULT;
    }

    if (conf.turn.onBegin === undefined) {
      conf.turn.onBegin = function (G) {
        return G;
      };
    }

    if (conf.turn.onEnd === undefined) {
      conf.turn.onEnd = function (G) {
        return G;
      };
    }

    if (conf.turn.endIf === undefined) {
      conf.turn.endIf = function () {
        return false;
      };
    }

    if (conf.turn.onMove === undefined) {
      conf.turn.onMove = function (G) {
        return G;
      };
    }

    if (conf.turn.stages === undefined) {
      conf.turn.stages = {};
    }

    for (var stage in conf.turn.stages) {
      var stageConfig = conf.turn.stages[stage];

      var _moves = stageConfig.moves || {};

      for (var _i2 = 0, _Object$keys2 = Object.keys(_moves); _i2 < _Object$keys2.length; _i2++) {
        var _move = _Object$keys2[_i2];
        var key = phase + '.' + stage + '.' + _move;
        moveMap[key] = _moves[_move];
        moveNames.add(_move);
      }
    }

    conf.onBegin = FnWrap(conf.onBegin, plugins);
    conf.onEnd = FnWrap(conf.onEnd, plugins);
    conf.turn.onMove = FnWrap(conf.turn.onMove, plugins);
    conf.turn.onBegin = FnWrap(conf.turn.onBegin, plugins);
    conf.turn.onEnd = FnWrap(conf.turn.onEnd, plugins);
  }

  function GetPhase(ctx) {
    return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];
  }

  function OnMove(s) {
    return s;
  }

  function Process(state, events) {
    var phasesEnded = new Set();
    var turnsEnded = new Set();

    for (var i = 0; i < events.length; i++) {
      var _events$i = events[i],
          fn = _events$i.fn,
          arg = _events$i.arg,
          rest = _objectWithoutProperties(_events$i, ["fn", "arg"]); // Detect a loop of EndPhase calls.
      // This could potentially even be an infinite loop
      // if the endIf condition of each phase blindly
      // returns true. The moment we detect a single
      // loop, we just bail out of all phases.


      if (fn === EndPhase) {
        turnsEnded.clear();
        var _phase = state.ctx.phase;

        if (phasesEnded.has(_phase)) {
          var ctx = _objectSpread2({}, state.ctx, {
            phase: null
          });

          return _objectSpread2({}, state, {
            ctx: ctx
          });
        }

        phasesEnded.add(_phase);
      } // Process event.


      var next = [];
      state = fn(state, _objectSpread2({}, rest, {
        arg: arg,
        next: next
      }));

      if (fn === EndGame) {
        break;
      } // Check if we should end the game.


      var shouldEndGame = ShouldEndGame(state);

      if (shouldEndGame) {
        events.push({
          fn: EndGame,
          arg: shouldEndGame,
          turn: state.ctx.turn,
          phase: state.ctx.phase,
          automatic: true
        });
        continue;
      } // Check if we should end the phase.


      var shouldEndPhase = ShouldEndPhase(state);

      if (shouldEndPhase) {
        events.push({
          fn: EndPhase,
          arg: shouldEndPhase,
          turn: state.ctx.turn,
          phase: state.ctx.phase,
          automatic: true
        });
        continue;
      } // Check if we should end the turn.


      if (fn === OnMove) {
        var shouldEndTurn = ShouldEndTurn(state);

        if (shouldEndTurn) {
          events.push({
            fn: EndTurn,
            arg: shouldEndTurn,
            turn: state.ctx.turn,
            phase: state.ctx.phase,
            automatic: true
          });
          continue;
        }
      }

      events.push.apply(events, next);
    }

    return state;
  } ///////////
  // Start //
  ///////////


  function StartGame(state, _ref2) {
    var next = _ref2.next;
    next.push({
      fn: StartPhase
    });
    return state;
  }

  function StartPhase(state, _ref3) {
    var next = _ref3.next;
    var G = state.G,
        ctx = state.ctx;
    var conf = GetPhase(ctx); // Run any phase setup code provided by the user.

    G = conf.onBegin(G, ctx);
    next.push({
      fn: StartTurn
    });
    return _objectSpread2({}, state, {
      G: G,
      ctx: ctx
    });
  }

  function StartTurn(state, _ref4) {
    var currentPlayer = _ref4.currentPlayer;
    var G = state.G,
        ctx = state.ctx;
    var conf = GetPhase(ctx); // Initialize the turn order state.

    if (currentPlayer) {
      ctx = _objectSpread2({}, ctx, {
        currentPlayer: currentPlayer
      });

      if (conf.turn.activePlayers) {
        ctx = SetActivePlayers(ctx, conf.turn.activePlayers);
      }
    } else {
      // This is only called at the beginning of the phase
      // when there is no currentPlayer yet.
      ctx = InitTurnOrderState(G, ctx, conf.turn);
    }

    var turn = ctx.turn + 1;
    ctx = _objectSpread2({}, ctx, {
      turn: turn,
      numMoves: 0,
      _prevActivePlayers: []
    });
    G = conf.turn.onBegin(G, ctx);
    var plainCtx = ContextEnhancer.detachAllFromContext(ctx);
    var _undo = [{
      G: G,
      ctx: plainCtx
    }];
    return _objectSpread2({}, state, {
      G: G,
      ctx: ctx,
      _undo: _undo,
      _redo: []
    });
  } ////////////
  // Update //
  ////////////


  function UpdatePhase(state, _ref5) {
    var arg = _ref5.arg,
        next = _ref5.next,
        phase = _ref5.phase;
    var conf = GetPhase({
      phase: phase
    });
    var _state = state,
        ctx = _state.ctx;

    if (arg && arg.next) {
      if (arg.next in phaseMap) {
        ctx = _objectSpread2({}, ctx, {
          phase: arg.next
        });
      } else {
        error('invalid phase: ' + arg.next);
        return state;
      }
    } else if (conf.next !== undefined) {
      ctx = _objectSpread2({}, ctx, {
        phase: conf.next
      });
    } else {
      ctx = _objectSpread2({}, ctx, {
        phase: null
      });
    }

    state = _objectSpread2({}, state, {
      ctx: ctx
    }); // Start the new phase.

    next.push({
      fn: StartPhase
    });
    return state;
  }

  function UpdateTurn(state, _ref6) {
    var arg = _ref6.arg,
        currentPlayer = _ref6.currentPlayer,
        next = _ref6.next;
    var _state2 = state,
        G = _state2.G,
        ctx = _state2.ctx;
    var conf = GetPhase(ctx); // Update turn order state.

    var _UpdateTurnOrderState = UpdateTurnOrderState(G, _objectSpread2({}, ctx, {
      currentPlayer: currentPlayer
    }), conf.turn, arg),
        endPhase = _UpdateTurnOrderState.endPhase,
        newCtx = _UpdateTurnOrderState.ctx;

    ctx = newCtx;
    state = _objectSpread2({}, state, {
      G: G,
      ctx: ctx
    });

    if (endPhase) {
      next.push({
        fn: EndPhase,
        turn: ctx.turn,
        phase: ctx.phase
      });
    } else {
      next.push({
        fn: StartTurn,
        currentPlayer: ctx.currentPlayer
      });
    }

    return state;
  }

  function UpdateStage(state, _ref7) {
    var arg = _ref7.arg,
        playerID = _ref7.playerID;

    if (typeof arg === 'string') {
      arg = {
        stage: arg
      };
    }

    var ctx = state.ctx;
    var _ctx = ctx,
        activePlayers = _ctx.activePlayers,
        _activePlayersMoveLimit = _ctx._activePlayersMoveLimit,
        _activePlayersNumMoves = _ctx._activePlayersNumMoves;

    if (arg.stage) {
      if (activePlayers === null) {
        activePlayers = {};
      }

      activePlayers[playerID] = arg.stage;
      _activePlayersNumMoves[playerID] = 0;

      if (arg.moveLimit) {
        if (_activePlayersMoveLimit === null) {
          _activePlayersMoveLimit = {};
        }

        _activePlayersMoveLimit[playerID] = arg.moveLimit;
      }
    }

    ctx = _objectSpread2({}, ctx, {
      activePlayers: activePlayers,
      _activePlayersMoveLimit: _activePlayersMoveLimit,
      _activePlayersNumMoves: _activePlayersNumMoves
    });
    return _objectSpread2({}, state, {
      ctx: ctx
    });
  } ///////////////
  // ShouldEnd //
  ///////////////


  function ShouldEndGame(_ref8) {
    var G = _ref8.G,
        ctx = _ref8.ctx;
    return endIf(G, ctx);
  }

  function ShouldEndPhase(_ref9) {
    var G = _ref9.G,
        ctx = _ref9.ctx;
    var conf = GetPhase(ctx);
    return conf.endIf(G, ctx);
  }

  function ShouldEndTurn(_ref10) {
    var G = _ref10.G,
        ctx = _ref10.ctx;
    var conf = GetPhase(ctx); // End the turn if the required number of moves has been made.

    var currentPlayerMoves = ctx.numMoves || 0;

    if (conf.turn.moveLimit && currentPlayerMoves >= conf.turn.moveLimit) {
      return true;
    }

    return conf.turn.endIf(G, ctx);
  } /////////
  // End //
  /////////


  function EndGame(state, _ref11) {
    var arg = _ref11.arg,
        phase = _ref11.phase;
    state = EndPhase(state, {
      phase: phase
    });

    if (arg === undefined) {
      arg = true;
    }

    return _objectSpread2({}, state, {
      ctx: _objectSpread2({}, state.ctx, {
        gameover: arg
      })
    });
  }

  function EndPhase(state, _ref12) {
    var arg = _ref12.arg,
        next = _ref12.next,
        turn = _ref12.turn,
        automatic = _ref12.automatic;
    // End the turn first.
    state = EndTurn(state, {
      turn: turn,
      force: true
    });
    var G = state.G;
    var ctx = state.ctx;

    if (next) {
      next.push({
        fn: UpdatePhase,
        arg: arg,
        phase: ctx.phase
      });
    } // If we aren't in a phase, there is nothing else to do.


    if (ctx.phase === null) {
      return state;
    } // Run any cleanup code for the phase that is about to end.


    var conf = GetPhase(ctx);
    G = conf.onEnd(G, ctx); // Reset the phase.

    ctx = _objectSpread2({}, ctx, {
      phase: null
    }); // Add log entry.

    var action = gameEvent('endPhase', arg);
    var logEntry = {
      action: action,
      _stateID: state._stateID,
      turn: state.ctx.turn,
      phase: state.ctx.phase
    };

    if (automatic) {
      logEntry.automatic = true;
    }

    var deltalog = [].concat(_toConsumableArray(state.deltalog), [logEntry]);
    return _objectSpread2({}, state, {
      G: G,
      ctx: ctx,
      deltalog: deltalog
    });
  }

  function EndTurn(state, _ref13) {
    var arg = _ref13.arg,
        next = _ref13.next,
        turn = _ref13.turn,
        force = _ref13.force,
        automatic = _ref13.automatic,
        playerID = _ref13.playerID;

    // This is not the turn that EndTurn was originally
    // called for. The turn was probably ended some other way.
    if (turn !== state.ctx.turn) {
      return state;
    }

    var G = state.G,
        ctx = state.ctx;
    var conf = GetPhase(ctx); // Prevent ending the turn if moveLimit hasn't been reached.

    var currentPlayerMoves = ctx.numMoves || 0;

    if (!force && conf.turn.moveLimit && currentPlayerMoves < conf.turn.moveLimit) {
      info("cannot end turn before making ".concat(conf.turn.moveLimit, " moves"));
      return state;
    } // Run turn-end triggers.


    G = conf.turn.onEnd(G, ctx);

    if (next) {
      next.push({
        fn: UpdateTurn,
        arg: arg,
        currentPlayer: ctx.currentPlayer
      });
    } // Reset activePlayers.


    ctx = _objectSpread2({}, ctx, {
      activePlayers: null
    }); // Remove player from playerOrder

    if (arg && arg.remove) {
      playerID = playerID || ctx.currentPlayer;
      var playOrder = ctx.playOrder.filter(function (i) {
        return i != playerID;
      });
      var playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;
      ctx = _objectSpread2({}, ctx, {
        playOrder: playOrder,
        playOrderPos: playOrderPos
      });

      if (playOrder.length === 0) {
        next.push({
          fn: EndPhase,
          turn: ctx.turn,
          phase: ctx.phase
        });
        return state;
      }
    } // Add log entry.


    var action = gameEvent('endTurn', arg);
    var logEntry = {
      action: action,
      _stateID: state._stateID,
      turn: state.ctx.turn,
      phase: state.ctx.phase
    };

    if (automatic) {
      logEntry.automatic = true;
    }

    var deltalog = [].concat(_toConsumableArray(state.deltalog || []), [logEntry]);
    return _objectSpread2({}, state, {
      G: G,
      ctx: ctx,
      deltalog: deltalog,
      _undo: [],
      _redo: []
    });
  }

  function EndStage(state, _ref14) {
    var arg = _ref14.arg,
        next = _ref14.next,
        automatic = _ref14.automatic,
        playerID = _ref14.playerID;
    playerID = playerID || state.ctx.currentPlayer;
    var ctx = state.ctx;
    var _ctx2 = ctx,
        activePlayers = _ctx2.activePlayers,
        _activePlayersMoveLimit = _ctx2._activePlayersMoveLimit;
    var playerInStage = activePlayers !== null && playerID in activePlayers;

    if (!arg && playerInStage) {
      var _conf = GetPhase(ctx);

      var _stage = _conf.turn.stages[activePlayers[playerID]];
      if (_stage && _stage.next) arg = _stage.next;
    }

    if (next && arg) {
      next.push({
        fn: UpdateStage,
        arg: arg,
        playerID: playerID
      });
    } // If player isn’t in a stage, there is nothing else to do.


    if (!playerInStage) return state; // Remove player from activePlayers.

    activePlayers = Object.keys(activePlayers).filter(function (id) {
      return id !== playerID;
    }).reduce(function (obj, key) {
      obj[key] = activePlayers[key];
      return obj;
    }, {});

    if (_activePlayersMoveLimit) {
      // Remove player from _activePlayersMoveLimit.
      _activePlayersMoveLimit = Object.keys(_activePlayersMoveLimit).filter(function (id) {
        return id !== playerID;
      }).reduce(function (obj, key) {
        obj[key] = _activePlayersMoveLimit[key];
        return obj;
      }, {});
    }

    ctx = UpdateActivePlayersOnceEmpty(_objectSpread2({}, ctx, {
      activePlayers: activePlayers,
      _activePlayersMoveLimit: _activePlayersMoveLimit
    })); // Add log entry.

    var action = gameEvent('endStage', arg);
    var logEntry = {
      action: action,
      _stateID: state._stateID,
      turn: state.ctx.turn,
      phase: state.ctx.phase
    };

    if (automatic) {
      logEntry.automatic = true;
    }

    var deltalog = [].concat(_toConsumableArray(state.deltalog || []), [logEntry]);
    return _objectSpread2({}, state, {
      ctx: ctx,
      deltalog: deltalog
    });
  }
  /**
   * Retrieves the relevant move that can be played by playerID.
   *
   * If ctx.activePlayers is set (i.e. one or more players are in some stage),
   * then it attempts to find the move inside the stages config for
   * that turn. If the stage for a player is '', then the player is
   * allowed to make a move (as determined by the phase config), but
   * isn't restricted to a particular set as defined in the stage config.
   *
   * If not, it then looks for the move inside the phase.
   *
   * If it doesn't find the move there, it looks at the global move definition.
   *
   * @param {object} ctx
   * @param {string} name
   * @param {string} playerID
   */


  function GetMove(ctx, name, playerID) {
    var conf = GetPhase(ctx);
    var stages = conf.turn.stages;
    var activePlayers = ctx.activePlayers;

    if (activePlayers && activePlayers[playerID] !== undefined && activePlayers[playerID] !== Stage.NULL && stages[activePlayers[playerID]] !== undefined && stages[activePlayers[playerID]].moves !== undefined) {
      // Check if moves are defined for the player's stage.
      var _stage2 = stages[activePlayers[playerID]];
      var _moves2 = _stage2.moves;

      if (name in _moves2) {
        return _moves2[name];
      }
    } else if (conf.moves) {
      // Check if moves are defined for the current phase.
      if (name in conf.moves) {
        return conf.moves[name];
      }
    } else if (name in moves) {
      // Check for the move globally.
      return moves[name];
    }

    return null;
  }

  function ProcessMove(state, action) {
    var conf = GetPhase(state.ctx);
    var _state3 = state,
        ctx = _state3.ctx;
    var _activePlayersNumMoves = ctx._activePlayersNumMoves;
    var playerID = action.playerID;
    if (ctx.activePlayers) _activePlayersNumMoves[playerID]++;
    var numMoves = state.ctx.numMoves;

    if (playerID == state.ctx.currentPlayer) {
      numMoves++;
    }

    state = _objectSpread2({}, state, {
      ctx: _objectSpread2({}, ctx, {
        numMoves: numMoves,
        _activePlayersNumMoves: _activePlayersNumMoves
      })
    });

    if (ctx._activePlayersMoveLimit && _activePlayersNumMoves[playerID] >= ctx._activePlayersMoveLimit[playerID]) {
      state = EndStage(state, {
        playerID: playerID,
        automatic: true
      });
    }

    var G = conf.turn.onMove(state.G, state.ctx, action);
    state = _objectSpread2({}, state, {
      G: G
    }); // Update undo / redo state.

    var undo = state._undo || [];
    var moveType = action.type;
    var plainCtx = ContextEnhancer.detachAllFromContext(state.ctx);
    state = _objectSpread2({}, state, {
      _undo: [].concat(_toConsumableArray(undo), [{
        G: state.G,
        ctx: plainCtx,
        moveType: moveType
      }]),
      _redo: []
    });
    var events = [{
      fn: OnMove
    }];
    return Process(state, events);
  }

  function SetStageEvent(state, playerID, arg) {
    return Process(state, [{
      fn: EndStage,
      arg: arg,
      playerID: playerID
    }]);
  }

  function EndStageEvent(state, playerID) {
    return Process(state, [{
      fn: EndStage,
      playerID: playerID
    }]);
  }

  function SetPhaseEvent(state, _playerID, newPhase) {
    return Process(state, [{
      fn: EndPhase,
      phase: state.ctx.phase,
      turn: state.ctx.turn,
      arg: {
        next: newPhase
      }
    }]);
  }

  function EndPhaseEvent(state) {
    return Process(state, [{
      fn: EndPhase,
      phase: state.ctx.phase,
      turn: state.ctx.turn
    }]);
  }

  function EndTurnEvent(state, _playerID, arg) {
    return Process(state, [{
      fn: EndTurn,
      turn: state.ctx.turn,
      phase: state.ctx.phase,
      arg: arg
    }]);
  }

  function PassEvent(state, _playerID, arg) {
    return Process(state, [{
      fn: EndTurn,
      turn: state.ctx.turn,
      phase: state.ctx.phase,
      force: true,
      arg: arg
    }]);
  }

  function EndGameEvent(state, _playerID, arg) {
    return Process(state, [{
      fn: EndGame,
      turn: state.ctx.turn,
      phase: state.ctx.phase,
      arg: arg
    }]);
  }

  var eventHandlers = {
    endStage: EndStageEvent,
    setStage: SetStageEvent,
    endTurn: EndTurnEvent,
    pass: PassEvent,
    endPhase: EndPhaseEvent,
    setPhase: SetPhaseEvent,
    endGame: EndGameEvent,
    setActivePlayers: SetActivePlayersEvent
  };
  var enabledEventNames = [];

  if (events.endTurn !== false) {
    enabledEventNames.push('endTurn');
  }

  if (events.pass !== false) {
    enabledEventNames.push('pass');
  }

  if (events.endPhase !== false) {
    enabledEventNames.push('endPhase');
  }

  if (events.setPhase !== false) {
    enabledEventNames.push('setPhase');
  }

  if (events.endGame !== false) {
    enabledEventNames.push('endGame');
  }

  if (events.setActivePlayers !== false) {
    enabledEventNames.push('setActivePlayers');
  }

  if (events.endStage !== false) {
    enabledEventNames.push('endStage');
  }

  if (events.setStage !== false) {
    enabledEventNames.push('setStage');
  }

  function ProcessEvent(state, action) {
    var _action$payload = action.payload,
        type = _action$payload.type,
        playerID = _action$payload.playerID,
        args = _action$payload.args;

    if (eventHandlers.hasOwnProperty(type)) {
      var eventArgs = [state, playerID].concat(args);
      return eventHandlers[type].apply({}, eventArgs);
    }

    return state;
  }

  function IsPlayerActive(_G, ctx, playerID) {
    if (ctx.activePlayers) {
      return playerID in ctx.activePlayers;
    }

    return ctx.currentPlayer === playerID;
  }

  return {
    ctx: function ctx(numPlayers) {
      return {
        numPlayers: numPlayers,
        turn: 0,
        currentPlayer: '0',
        playOrder: _toConsumableArray(new Array(numPlayers)).map(function (_d, i) {
          return i + '';
        }),
        playOrderPos: 0,
        phase: startingPhase,
        activePlayers: null
      };
    },
    init: function init(state) {
      return Process(state, [{
        fn: StartGame
      }]);
    },
    isPlayerActive: IsPlayerActive,
    eventHandlers: eventHandlers,
    eventNames: Object.keys(eventHandlers),
    enabledEventNames: enabledEventNames,
    moveMap: moveMap,
    moveNames: _toConsumableArray(moveNames.values()),
    processMove: ProcessMove,
    processEvent: ProcessEvent,
    getMove: GetMove
  };
}

/**
 * Game
 *
 * Helper to generate the game move reducer. The returned
 * reducer has the following signature:
 *
 * (G, action, ctx) => {}
 *
 * You can roll your own if you like, or use any Redux
 * addon to generate such a reducer.
 *
 * The convention used in this framework is to
 * have action.type contain the name of the move, and
 * action.args contain any additional arguments as an
 * Array.
 *
 * @param {...object} setup - Function that returns the initial state of G.
 *
 * @param {...object} moves - A dictionary of move functions.
 *
 * @param {...object} playerView - A function that returns a
 *                                 derivative of G tailored for
 *                                 the specified player.
 *
 * @param {...object} seed - Seed for the PRNG.
 *
 * @param {Array} plugins - List of plugins. Each plugin is an object like the following:
 *                          {
 *                            // Optional: Wraps a move / trigger function and returns
 *                            // the wrapped function. The wrapper can do anything
 *                            // it wants, but will typically be used to customize G.
 *                            fnWrap: (fn) => {
 *                              return (G, ctx, ...args) => {
 *                                G = preprocess(G);
 *                                G = fn(G, ctx, ...args);
 *                                G = postprocess(G);
 *                                return G;
 *                              };
 *                            },
 *
 *                            // Optional: Called during setup. Can be used to
 *                            // augment G with additional state during setup.
 *                            setup: (G, ctx) => G,
 *                          }
 */

function Game(game) {
  // The Game() function has already been called on this
  // config object, so just pass it through.
  if (game.processMove) {
    return game;
  }

  if (game.name === undefined) game.name = 'default';
  if (game.setup === undefined) game.setup = function () {
    return {};
  };
  if (game.moves === undefined) game.moves = {};
  if (game.playerView === undefined) game.playerView = function (G) {
    return G;
  };
  if (game.plugins === undefined) game.plugins = [];

  if (game.name.includes(' ')) {
    throw new Error(game.name + ': Game name must not include spaces');
  }

  var flow = Flow(game);
  return _objectSpread2({}, game, {
    flow: flow,
    moveNames: flow.moveNames,
    processMove: function processMove(G, action, ctx) {
      var moveFn = flow.getMove(ctx, action.type, action.playerID);

      if (moveFn instanceof Object && moveFn.move) {
        moveFn = moveFn.move;
      }

      if (moveFn instanceof Function) {
        var ctxWithPlayerID = _objectSpread2({}, ctx, {
          playerID: action.playerID
        });

        var args = [G, ctxWithPlayerID].concat(action.args);
        var fn = FnWrap(moveFn, game.plugins);
        return fn.apply(void 0, _toConsumableArray(args));
      }

      return G;
    }
  });
}

/**
 * Returns true if a move can be undone.
 */

var CanUndoMove = function CanUndoMove(G, ctx, move) {
  if (move.undoable === false) {
    return false;
  }

  if (move.undoable instanceof Function) {
    return move.undoable(G, ctx);
  }

  return true;
};
/**
 * Moves can return this when they want to indicate
 * that the combination of arguments is illegal and
 * the move ought to be discarded.
 */


var INVALID_MOVE = 'INVALID_MOVE';
/**
 * CreateGameReducer
 *
 * Creates the main game state reducer.
 * @param {...object} game - Return value of Game().
 * @param {...object} numPlayers - The number of players.
 * @param {...object} multiplayer - Set to a truthy value if we are in a multiplayer client.
 */

function CreateGameReducer(_ref) {
  var game = _ref.game,
      multiplayer = _ref.multiplayer;
  game = Game(game);
  /**
   * GameReducer
   *
   * Redux reducer that maintains the overall game state.
   * @param {object} state - The state before the action.
   * @param {object} action - A Redux action.
   */

  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case GAME_EVENT:
        {
          state = _objectSpread2({}, state, {
            deltalog: []
          }); // Process game events only on the server.
          // These events like `endTurn` typically
          // contain code that may rely on secret state
          // and cannot be computed on the client.

          if (multiplayer) {
            return state;
          } // Disallow events once the game is over.


          if (state.ctx.gameover !== undefined) {
            error("cannot call event after game end");
            return state;
          } // Ignore the event if the player isn't active.


          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {
            error("disallowed event: ".concat(action.payload.type));
            return state;
          } // Enhance ctx with API.


          var apiCtx = new ContextEnhancer(state.ctx, game, action.payload.playerID);
          state.ctx = apiCtx.attachToContext(state.ctx); // Execute plugins.

          state = BeforeEvent(state, game.plugins); // Process event.

          var newState = game.flow.processEvent(state, action);
          newState = apiCtx.updateAndDetach(newState, true); // Execute plugins.

          newState = AfterEvent(newState, game.plugins);
          return _objectSpread2({}, newState, {
            _stateID: state._stateID + 1
          });
        }

      case MAKE_MOVE:
        {
          state = _objectSpread2({}, state, {
            deltalog: []
          }); // Check whether the move is allowed at this time.

          var move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);

          if (move === null) {
            error("disallowed move: ".concat(action.payload.type));
            return state;
          } // Don't run move on client if move says so.


          if (multiplayer && move.client === false) {
            return state;
          } // Disallow moves once the game is over.


          if (state.ctx.gameover !== undefined) {
            error("cannot make move after game end");
            return state;
          } // Ignore the move if the player isn't active.


          if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {
            error("disallowed move: ".concat(action.payload.type));
            return state;
          }

          var _apiCtx = new ContextEnhancer(state.ctx, game, action.payload.playerID);

          var ctxWithAPI = _apiCtx.attachToContext(state.ctx); // Execute plugins.


          state = BeforeMove(state, game.plugins); // Process the move.

          var G = game.processMove(state.G, action.payload, ctxWithAPI); // The game declared the move as invalid.

          if (G === INVALID_MOVE) {
            error("invalid move: ".concat(action.payload.type, " args: ").concat(action.payload.args));
            return state;
          } // Create a log entry for this move.


          var logEntry = {
            action: action,
            _stateID: state._stateID,
            turn: state.ctx.turn,
            phase: state.ctx.phase
          };

          if (move.redact === true) {
            logEntry.redact = true;
          } // Don't call into events here.


          var _newState = _apiCtx.updateAndDetach(_objectSpread2({}, state, {
            deltalog: [logEntry]
          }), false);

          var ctx = _newState.ctx; // Random API code was executed. If we are on the
          // client, wait for the master response instead.

          if (multiplayer && ctx._random !== undefined && ctx._random.prngstate !== undefined) {
            return state;
          }

          state = _objectSpread2({}, _newState, {
            G: G,
            ctx: ctx,
            _stateID: state._stateID + 1
          }); // Execute plugins.

          state = AfterMove(state, game.plugins); // If we're on the client, just process the move
          // and no triggers in multiplayer mode.
          // These will be processed on the server, which
          // will send back a state update.

          if (multiplayer) {
            return state;
          } // Allow the flow reducer to process any triggers that happen after moves.


          ctxWithAPI = _apiCtx.attachToContext(state.ctx);
          state = game.flow.processMove(_objectSpread2({}, state, {
            ctx: ctxWithAPI
          }), action.payload);
          state = _apiCtx.updateAndDetach(state, true);
          return state;
        }

      case RESET:
      case UPDATE:
      case SYNC:
        {
          return action.state;
        }

      case UNDO:
        {
          var _state = state,
              _undo = _state._undo,
              _redo = _state._redo;

          if (_undo.length < 2) {
            return state;
          }

          var last = _undo[_undo.length - 1];
          var restore = _undo[_undo.length - 2]; // Only allow undoable moves to be undone.

          var lastMove = game.flow.getMove(state.ctx, last.moveType, state.ctx.currentPlayer);

          if (!CanUndoMove(state.G, state.ctx, lastMove)) {
            return state;
          }

          return _objectSpread2({}, state, {
            G: restore.G,
            ctx: restore.ctx,
            _undo: _undo.slice(0, _undo.length - 1),
            _redo: [last].concat(_toConsumableArray(_redo))
          });
        }

      case REDO:
        {
          var _state2 = state,
              _undo2 = _state2._undo,
              _redo2 = _state2._redo;

          if (_redo2.length == 0) {
            return state;
          }

          var first = _redo2[0];
          return _objectSpread2({}, state, {
            G: first.G,
            ctx: first.ctx,
            _undo: [].concat(_toConsumableArray(_undo2), [first]),
            _redo: _redo2.slice(1)
          });
        }

      default:
        {
          return state;
        }
    }
  };
}

export { ActionCreators as A, CreateGameReducer as C, Game as G, INVALID_MOVE as I, MAKE_MOVE as M, Random as R, Setup as S, TurnOrder as T, UPDATE as U, alea as a, ContextEnhancer as b, redo as c, GAME_EVENT as d, error as e, RESET as f, gameEvent as g, SYNC as h, ActivePlayers as i, Stage as j, update as k, UNDO as l, makeMove as m, REDO as n, reset as r, sync as s, undo as u };
